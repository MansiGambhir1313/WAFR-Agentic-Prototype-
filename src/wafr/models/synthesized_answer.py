"""
SynthesizedAnswer data model for AI-generated answers.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Any, Optional


class SynthesisMethod(str, Enum):
    """Method used to synthesize the answer."""
    EVIDENCE_BASED = "EVIDENCE_BASED"  # Direct evidence in transcript
    INFERENCE = "INFERENCE"  # Logical inference from context
    BEST_PRACTICE = "BEST_PRACTICE"  # AWS best practice applied
    FALLBACK = "FALLBACK"  # Minimal context, low confidence


@dataclass
class EvidenceQuote:
    """Evidence quote from transcript supporting the answer."""
    text: str
    location: str  # e.g., "transcript:line:87"
    relevance: str  # Explanation of why this quote is relevant


@dataclass
class SynthesizedAnswer:
    """
    AI-synthesized answer for a gap WAFR question.
    
    This represents an answer generated by the Answer Synthesis Agent
    (enhanced InferenceAgent) that requires human review and validation.
    """
    # Identity (required fields)
    question_id: str
    pillar: str  # SEC, REL, PERF, COST, OPS, SUS
    question_text: str
    synthesized_answer: str  # Required field
    
    # Optional fields with defaults
    criticality: str = "MEDIUM"  # HIGH, MEDIUM, LOW
    reasoning_chain: List[str] = field(default_factory=list)
    assumptions: List[str] = field(default_factory=list)
    
    # Confidence
    confidence: float = 0.5  # 0.0 - 1.0
    confidence_justification: str = ""
    synthesis_method: SynthesisMethod = SynthesisMethod.INFERENCE
    
    # Evidence
    evidence_quotes: List[EvidenceQuote] = field(default_factory=list)
    related_insights: List[str] = field(default_factory=list)  # Insight IDs
    
    # Review Guidance
    requires_attention: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "question_id": self.question_id,
            "pillar": self.pillar,
            "question_text": self.question_text,
            "criticality": self.criticality,
            "synthesized_answer": self.synthesized_answer,
            "reasoning_chain": self.reasoning_chain,
            "assumptions": self.assumptions,
            "confidence": self.confidence,
            "confidence_justification": self.confidence_justification,
            "synthesis_method": self.synthesis_method.value,
            "evidence_quotes": [
                {
                    "text": eq.text,
                    "location": eq.location,
                    "relevance": eq.relevance
                }
                for eq in self.evidence_quotes
            ],
            "related_insights": self.related_insights,
            "requires_attention": self.requires_attention,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SynthesizedAnswer":
        """Create from dictionary."""
        evidence_quotes = [
            EvidenceQuote(
                text=eq.get("text", ""),
                location=eq.get("location", ""),
                relevance=eq.get("relevance", "")
            )
            for eq in data.get("evidence_quotes", [])
        ]
        
        synthesis_method = SynthesisMethod(
            data.get("synthesis_method", "INFERENCE")
        )
        
        return cls(
            question_id=data["question_id"],
            pillar=data.get("pillar", ""),
            question_text=data.get("question_text", ""),
            criticality=data.get("criticality", "MEDIUM"),
            synthesized_answer=data["synthesized_answer"],
            reasoning_chain=data.get("reasoning_chain", []),
            assumptions=data.get("assumptions", []),
            confidence=data.get("confidence", 0.5),
            confidence_justification=data.get("confidence_justification", ""),
            synthesis_method=synthesis_method,
            evidence_quotes=evidence_quotes,
            related_insights=data.get("related_insights", []),
            requires_attention=data.get("requires_attention", []),
        )

